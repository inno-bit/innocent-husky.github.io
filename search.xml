<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[奇偶性判断的后续问题]]></title>
    <url>%2F2019%2F03%2F29%2F%E5%A5%87%E5%81%B6%E6%80%A7%E5%88%A4%E6%96%AD%E7%9A%84%E5%90%8E%E7%BB%AD%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[这可能是历史上最简单的一道Java面试题： 判断一个整数是否是偶数 1public boolean isEven(int i) 是否觉得无聊?no,no,no….. 让我看看可能给出的答案 1234567public boolean isEven(int i)&#123; if(i%2==0)&#123; System.out.println(i+"是偶数"); &#125;else&#123; System.out.println(i+"是偶数"); &#125;&#125; of course这个答案必然是编译期报错 想了想，要求返回布尔值，所以需要改改 1234567public boolean isEven(int i)&#123; if(i%2==0)&#123; return true; &#125;else&#123; return false; &#125;&#125; 可是你不觉得，这么写真的太多了吗？if判断语句里面就是布尔类型啊 于是… 123public boolean isEven(int i)&#123; return i%2==0;&#125; 舒服了很多 结束了？no,no,no… 计算机底层所有数据是二进制（例如0110101011形式）,因此位运算相对于数学取模运算是更快的 因此更好的选择是： 奇数odd的二进制数必定最后一个是1 偶数even的二进制数必定最后一个是0 根据 且&amp;这个位运算，对整数奇偶性进行判断 位移&gt;&gt;和&lt;&lt;操作符 当然不止上面两种… 123public boolean isEven(int i)&#123; return (i&amp;1) != 1;&#125; 123public boolean isEven(int i)&#123; return i&gt;&gt;1&lt;&lt;1 ==i;&#125; 代码测试上面的都是理论上的判断，实际又是如何的呢？ talk is cheap ,show me the code 几种不同的判断方法 12345678910111213141516171819202122232425262728293031323334353637public class Test&#123; public static void main(String[] args) &#123; final int N=100000; test(Test::isEven1,N); test(Test::isEven2,N); &#125; public static boolean isEven1(int i)&#123; return i%2==0; &#125; public static boolean isEven2(int i)&#123; return (i&amp;1)!=1; &#125; public static long test(func f,int n) throws IllegalArgumentException&#123; if(n&lt;1) throw new IllegalArgumentException("n must be greater than ZERO"); int count=0; long start=System.currentTimeMillis(); for (int i = 0; i &lt; n; i++) &#123; f.judge(i); count++; &#125; long end=System.currentTimeMillis(); long time=end-start; System.out.println("完成时间："+time); return time; &#125;&#125;@FunctionalInterfaceinterface func&#123; boolean judge(int i);&#125; 测试结果： 1234567891011//第一次完成时间：5完成时间：8//第二次完成时间：5完成时间：6//第三次完成时间：5完成时间：4 实际结果显示%取模运算和&amp;运算运行时间差不多，这是为什么？？？？ ==编译器优化== 逻辑上程序进行%取模运算，判断奇偶性，但编译器对这段代码进行了等价的位运算替代，也就是进行了优化，甚至比我们手动优化更好 这也是上面实际测试结果显示的原因 转载自文章：记一道简单的java面试题]]></content>
      <categories>
        <category>程序员为难程序员</category>
      </categories>
      <tags>
        <tag>小测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String类基本解读]]></title>
    <url>%2F2019%2F03%2F24%2FString%E7%B1%BB%E5%9F%BA%E6%9C%AC%E8%A7%A3%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[原始字符类型char，引用类型String字符串，从字面上含义就可以看出两者的关系，String字符串是char字符的一个有序序列 因为不同版本JDK的String类有些许区别，这里以下面版本为准 JDK版本9.0.4 所属模块java.base 所属包java.lang 需要导入的包 123456789101112131415161718import java.io.ObjectStreamField;import java.io.UnsupportedEncodingException;import java.nio.charset.Charset;import java.util.ArrayList;import java.util.Arrays;import java.util.Comparator;import java.util.Formatter;import java.util.Locale;import java.util.Objects;import java.util.Spliterator;import java.util.StringJoiner;import java.util.regex.Matcher;import java.util.regex.Pattern;import java.util.regex.PatternSyntaxException;import java.util.stream.IntStream;import java.util.stream.StreamSupport;import jdk.internal.HotSpotIntrinsicCandidate;import jdk.internal.vm.annotation.Stable; 这里个人还没能力解读，跳过，待后续解读 String类声明 12public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence 默认继承Object 实现Serializable，是为了实现序列化 实现Comparable，是为了字符串之间的可比较性 实现CharSequence 属性12345678private final byte[] value;//字符串底层实现byte[]private final byte coder; //latin1还是utf16private int hash;private static final long serialVersionUID = -6849794470754667710L;//实现Serializable接口原因//静态staticstatic final byte LATIN1 = 0;static final byte UTF16 = 1; 构造函数 String类的构造函数有很多，有些使用注解@Deprecated（这里没有显示，但是API文档里面有的）表示过时的，这些API是由于历史遗留问题，很多计算机还在使用比较古老的JDK版本，为了保证兼容性而保留，但是在开发出最好不要使用这些过时API 构造函数很多，但是需要掌握的只有红圈中的几个，字符串从字面上理解就是char[]，底层的实现是byte[] ，因为char byte int之间具有相互转化的关系，所以构造函数也可以接受int[] 还有一种需要特别注意的是：字符串字面量（例如：”abc”，”sfap”），这些也是String类的实例对象 方法String类的方法很多，这里确实无法一一列举，就简单的分类介绍一下其作用 字符串条件判断类型方法 12345678910boolean equals(String other);boolean equalsIgnoreCase(String other);//字符串是引用类型，这里的比较其值是否相等，而不是引用地址boolean contains(CharSequence s);//是否包含字串boolean isBlank()boolean isEmpty()boolean startsWith(String prefix)boolean endsWith(String suffix)boolean matches(String regex) 获取字符串状态方法 123456char charAt(int index)int codePointAt(int index) //获取字符串某个字符的unicode码点int indexOf(int ch)int lastIndexOf(int ch)String substring(int beginIndex)//截取字串int length() 字符串操作类型方法 1234567String toUpperCase()String toLowerCase()// 这里介绍一个Java暂时没有的方法 String toCapitalize()实现首字母大写String trim()String[] split(String regex)String repeat(int count)String replace(String old, String new) 对于valueOf()方法需要明白：这是一个重载的方法，可以接受多种类型的参数，对于引用对象类型，大部分会调用这个对象的toString()方法，这也是System.out.println()可以打印多种数据类型的原因 由于String类中方法实现很多，这里无法完全展现其中的方法原理，有待后续解读吧 字符串字面量与常量池在正式进入常量池之前，首先简单地介绍一下JVM（Java虚拟机，由于市面上有多种不同的JVM，本文中仅考虑Hotspot VM）的内存结构，也是作为Java程序员必须要了解的内容 什么是字面量？ 12int a = 123;String s = "some"; 像123和&quot;some&quot;这写从字面上就代表其值的量就是字面量，而s,a都不是变量，因为不能从这些变量的符号上直接看到其代表的值 常量池（pool of instant）也称为运行时常量池 常量池主要用来存放两大类常量：字面量和符号引用量，字面量相当于Java语言的常量，如文本字符串，声明为final的常量等，符号引用包括以下三种 类和接口的全限定名 字段名称和描述符 方法名称和描述符 在jvm规范中，每个类型（Float,Double貌似没有，个人这里没有弄清楚）都有自己的常量池。常量池是某类型所用常量的一个有序集合 本质：实现常量池是为了减少Java程序运行时的内存占用，如果对于常量每个被引用对象都保存一份内存副本，这对大大增减程序运行时的负荷 String类的不可变性什么叫做类的不可变性（immutable）？简单的说，就是其实例对象一旦创建完成，在其整个生命周期内状态都不会发生变化。状态这个词有一些抽象，在Java中对象的状态是有其内部成员变量来表现的，那么状态不变即使成员变量不变（具体来说，基本类型变量的值不变，引用类型变量的引用地址不变）。 为了使类成为不可变的，要遵循下面五条规则（引用自《Effective Java》）: 保证类不会被扩展，添加类声明finnal class 所有成员变量都是final的 所有成员变量都是private 如果一个类成员变量引用了可变对象，则必须确保外部调用类无法获取指向这些对象的引用 不提供任可能修改对象状态的方法 当然，所有的这些都是针对正常调用而言，如果使用反射机，则仅仅满足上面的条件也是无法保证对象的不可变性 不可变类的用处： 更加易于设计、实现和使用 并发时，不容易出错，并且更加安全 为什么String要设计为不可变呢？主要原因如下： 字符串池（String pool）的需求。之前已经说过，通过字面量发初始化一个Java字符串时，会将这个字符串保存在常量池中。如果定义了另外一个相同值的字符串变量，则直接指向之前初始化的那个对象。如果字符串是可变的，改变另一个字符串变量，就会使另一个字符串变量指向错误的值。 缓存字符串hashcode码的需要。字符串的hashcode是经常被使用的，字符串的不变性确保了hashcode的值一直是一样的，在需要hashcode时，就不需要每次都计算，这样会很高效。 出于安全性考虑。字符串经常作为网络连接、数据库连接等参数，不可变就可以保证连接的安全性 String、StringBuffer与StringBuilder 类 可变性 线程安全 String 不可变 线程安全 StringBuffer 可变 线程安全 StringBuilder 可变 非线程安全 三者在字符串拼接上存在性能差异 1234567891011121314151617181920212223242526272829final int N = 100000;String string = "";StringBuffer stringBuffer = new StringBuffer("");StringBuilder stringBuilder = new StringBuilder("");long start = System.currentTimeMillis();for (int i = 0; i &lt; N; i++) &#123; string += i;&#125;long end = System.currentTimeMillis();long time = end-start;System.out.println("String消耗时间：" + time);start = System.currentTimeMillis();for (int i = 0; i &lt; N; i++) &#123; stringBuffer.append(i);&#125;end = System.currentTimeMillis();time = end-start;System.out.println("StringBuffer消耗时间：" + time);start = System.currentTimeMillis();for (int i = 0; i &lt; N; i++) &#123; stringBuilder.append(i);&#125;end = System.currentTimeMillis();time = end-start;System.out.println("StringBuilder消耗时间：" + time); 输出结果 123String消耗时间：4761StringBuffer消耗时间：5StringBuilder消耗时间：3 String每次拼接都会产生新String对象，因此速度相对于其他两者慢很多 理论上StringBuilder最快，但是设计线程安全的时候必须使用StringBuffer 字符串的+字符串的+表示字符串的拼接，而不是数学运算上的加号，个人的理解是Java对String类的+号运算符重载实现 1System.out.println("some"+"xxxx"); //"somexxxx” 只有数字Number类及其子类，String类，基本数字数据类型使用+才是有意义的]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java序列化]]></title>
    <url>%2F2019%2F03%2F22%2FJava%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[什么是序列化和反序列化？ 序列化（Serialization）是将对象的状态信息转化为可以存储或者传输的形式的过程 反序列化（Deserialization）是序列化的反向解析过程，将持久化存储的信息转化成内存中的对象等数据的过程 从存储层次而言，计算机computer的存储分为持久存储和非持久存储：内存和CPU缓存等在计算机通电的情况下可以保存信息，然后断电后就失去了所有的信息，因此就需要磁盘这种存储设备来尽可能持久的保存信息。 Java虚拟机JVM是运行在内存中的软件，为了是如下目的，需要对对象object进行序列化： 实现对象的持久化存储 方便对象的网络传送 实现网络的远程调度 这些目的不是独立的，而是相互作为基础的关系，有对象序列化的基础，实现对象持久化存储，以方便对象的网络传输，再在远端反序列化生成对象，进行远程调度，这使得程序更具维护性。 序列化方式 通过生成二进制字节码，实现对象序列化，这种方式保持类型保真度 XML 序列化仅序列化公共属性和字段，且不保持类型保真度 JSON序列化，与XML类似，当JSON的序列化后文件比XML更加精简 还有很多其他实现序列化的方式 FastJson序列化 ProtoBuff序列化 …… 上面给出了几个Java实现序列化的方式，了解前面几种即可，但是本质是必须清楚的： ​ 实现对象等数据的可持久化存储和网络传输 序列化图解 上图是Java中使用字节流方式实现序列化和反序列化的大致流程 Java序列化和反序列化Demo注意：这里代码是通过二进制字节流的方式实现Java的序列化 序列化借助ObjectOutputStream 类的writeObject(Object x)方法实现对象数据的序列化 1public final void writeObject(Object obj) throws IOException&#123;...&#125; 这里可能抛出IOException异常 然后借助FileOutputStream类将序列化的二进制字节流写入指定的的路径文件中 1public FileOutputStream(String name) throws FileNotFoundException&#123;...&#125; 这里可能抛出FileNotFoundException异常 反序列化则需要借助相应的FileInputStream类和ObjectInputStream 类的readObject()方法 这个阶段可能抛出FileNotFoundException和IOException异常 对于这写可能抛出的异常需要使用相对应的try/catch语句进行捕获 Employee类 123456789101112public class Employee implements java.io.Serializable&#123; public String name; public String address; public transient int SSN; public int number; public void mailCheck() &#123; System.out.println("Mailing a check to " + name + " " + address); &#125;&#125; 序列化代码 12345678910111213141516171819202122232425import java.io.*;public class SerializeDemo&#123; public static void main(String [] args) &#123; Employee e = new Employee(); e.name = "Reyan Ali"; e.address = "Phokka Kuan, Ambehta Peer"; e.SSN = 11122333; e.number = 101; try &#123; FileOutputStream fileOut = new FileOutputStream("./employee.ser"); ObjectOutputStream out = new ObjectOutputStream(fileOut); out.writeObject(e); out.close(); fileOut.close(); System.out.printf("Serialized data is saved in ./employee.ser"); &#125;catch(IOException i) &#123; i.printStackTrace(); &#125; &#125;&#125; 这会把对象e序列化到当前Java工程的根目录下的employee.ser文件中，使用sublime或者notepad++十六进制打开文件 序列化后文件解读（待续……）TODO 反序列化代码 1234567891011121314151617181920212223242526272829303132import java.io.*;public class DeserializeDemo&#123; public static void main(String [] args) &#123; Employee e = null; try &#123; FileInputStream fileIn = new FileInputStream("./employee.ser"); ObjectInputStream in = new ObjectInputStream(fileIn); e = (Employee) in.readObject(); in.close(); fileIn.close(); &#125;catch(IOException i) &#123; i.printStackTrace(); return; &#125;catch(ClassNotFoundException c) &#123; System.out.println("Employee class not found"); c.printStackTrace(); return; &#125; System.out.println("Deserialized Employee..."); System.out.println("Name: " + e.name); System.out.println("Address: " + e.address); System.out.println("SSN: " + e.SSN); System.out.println("Number: " + e.number); System.out.println(ee instanceof Employee); &#125;&#125; 以上程序编译运行结果如下所示： 123456Deserialized Employee...Name: Reyan AliAddress:Phokka Kuan, Ambehta PeerSSN: 0Number:101true Java序列化语法 一个类想要序列化成功必须满足一些条件： 该类必须实现 java.io.Serializable 接口 该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的，有transient关键字修饰 静态static修饰的成员不会被序列化，因为它们是属于类的，而不是某个具体对象的 如果子类实现Serializable接口而父类未实现时，父类不会被序列化！如果父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口。 序列化技术存在的问题整个过程都是Java虚拟机（JVM）独立的，也就是说，在一个平台（Windows，Linux，MacOS）上序列化的对象可以在另一个完全不同的平台上反序列化该对象 序列化技术中有三个过程：序列化，网络传输，反序列化这三个过程都存在严重的安全问题，据不完全统计，至少有3分之1的漏洞是序列化带来的 考虑到这些因素，目前 Oracle 公司计划废除 Java 中的古董—序列化技术，但是序列化技术在Java编程中使用非常的广泛，对此删除序列化技术将是一个长期的计划。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组array]]></title>
    <url>%2F2019%2F03%2F19%2F%E6%95%B0%E7%BB%84array%2F</url>
    <content type="text"><![CDATA[java数组array是固定个数的同种兼容数据类型数据的组织形式 这里首先说下个人自己的观点：array是数据的组织形式，在内存中一段连续的地址空间，但是还没有到达容器的程度，因为数组中元素可以自由访问，没有容器的读写限制 数组的静态和动态创建 静态创建方式： 123int[] arr1=&#123;1,2,3,4&#125;;//或者int[] arr2=new int[]&#123;1,2,3,4&#125;; 创建的时候，确定了数组中的元素值和长度 动态创建方式： 1int[] arr=new int[4]; 创建的时候，不确定数组中的元素值，但是可以确定数组长度 注意： 静态创建方式和动态创建方式不能一起混用，例如下面就会保存 1int[] arr=new int[4]&#123;1,2,3,4&#125;; //报错 数组静态创建和动态创建的区别？ 数组Array的静态创建和动态创建在于创建的时候，是否给数组中元素赋值 数组元素的默认初始化initialization数组静态创建还是动态创建的过程如下： 堆heap分配固定长度内存空间 数组内元素默认初始化default initialization 静态创建与动态创建，此阶段不同： 静态创建，此时给数组中元素用声明的值重新赋值 动态创建，只有默认初始化，是否赋值交给后面的代码 数组的形式是type[]，针对不同的type存在不同的默认初始化值 byte short int long float double默认值0和其变体形式0L 0.0F 0.0D char 默认值 \u0000 引用数据类型默认值 null 数组常见异常 java.lang.ArrayIndexOutOfBoundsException 访问数组索引越界异常 数组是程序运行时兼容数据类型 | 固定长度 | 内存地址连续的引用数据类型 可访问索引范围 index \in [0,n-1] 因此索引越界异常只有：1）上限越界，例如-1 2）下限越界，例如n java.lang.NullPointerException 数组空指针异常 数组在Java中属于引用数据类型，null是任何引用数据类型的默认空值 当int[] arr = null时候，变量arr指向null表示空，因此不存在arr[0]，也不存在任何数组元素 java.lang.NegativeArraySizeException数组初始化长度异常 java.lang.ArrayStoreException数组元素存储异常 数组与对象的关系12int[] arr=new int[4]; System.out.println(arr instanceof int[]); //true 这里使用了new关键字，表示数组也是一种对象类型 而且instanceof运算符的断言结果true也佐证了这一点 ✳数组是特殊的对象，父类是Object类 数组的length属性public， final，int的，因此数组的长度一旦确定，在程序运行阶段是无法改变的 数组的维度Dimension和内存图一维数组：int arr[] = new int[3] 二维数组： 1234int[ ][ ] arr = new int[3][ ]; arr[0] = new int[3]; arr[1] = new int[5]; arr[2] = new int[4]; 扩展：存在3，4，……N维度数组 但是实际上，内存地址是一维线性的，所以内存中除了第一维数组的元素是连续存储的，其他的都是零散无规律分布的 数组不支持泛型比如： 1List&lt;String&gt;[] arr = new ArrayList&lt;String&gt;[10]; 会报错，无法编译通过 根本的原因是：数组在创建的时候必须知道内部元素的类型，而且一直都会记得这个类型信息，每次往数组里添加元素，都会做类型检查。 但因为Java泛型是用擦除（Erasure）实现的，运行时类型参数会被擦掉。所以对于泛型数组，编译器看不到泛型的String类型参数。数组由于无法确定所持有元素的类型，所以不允许初始化 数组协变等待后续…… 数组相关类]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
