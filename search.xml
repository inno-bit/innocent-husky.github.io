<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java序列化]]></title>
    <url>%2F2019%2F03%2F22%2FJava%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[什么是序列化和反序列化？ 序列化（Serialization）是将对象的状态信息转化为可以存储或者传输的形式的过程 反序列化（Deserialization）是序列化的反向解析过程，将持久化存储的信息转化成内存中的对象等数据的过程 从存储层次而言，计算机computer的存储分为持久存储和非持久存储：内存和CPU缓存等在计算机通电的情况下可以保存信息，然后断电后就失去了所有的信息，因此就需要磁盘这种存储设备来尽可能持久的保存信息。 Java虚拟机JVM是运行在内存中的软件，为了是如下目的，需要对对象object进行序列化： 实现对象的持久化存储 方便对象的网络传送 实现网络的远程调度 这些目的不是独立的，而是相互作为基础的关系，有对象序列化的基础，实现对象持久化存储，以方便对象的网络传输，再在远端反序列化生成对象，进行远程调度，这使得程序更具维护性。 序列化方式 通过生成二进制字节码，实现对象序列化，这种方式保持类型保真度 XML 序列化仅序列化公共属性和字段，且不保持类型保真度 JSON序列化，与XML类似，当JSON的序列化后文件比XML更加精简 还有很多其他实现序列化的方式 FastJson序列化 ProtoBuff序列化 …… 上面给出了几个Java实现序列化的方式，了解前面几种即可，但是本质是必须清楚的： ​ 实现对象等数据的可持久化存储和网络传输 序列化图解 上图是Java中使用字节流方式实现序列化和反序列化的大致流程 Java序列化和反序列化Demo注意：这里代码是通过二进制字节流的方式实现Java的序列化 序列化借助ObjectOutputStream 类的writeObject(Object x)方法实现对象数据的序列化 1public final void writeObject(Object obj) throws IOException&#123;...&#125; 这里可能抛出IOException异常 然后借助FileOutputStream类将序列化的二进制字节流写入指定的的路径文件中 1public FileOutputStream(String name) throws FileNotFoundException&#123;...&#125; 这里可能抛出FileNotFoundException异常 反序列化则需要借助相应的FileInputStream类和ObjectInputStream 类的readObject()方法 这个阶段可能抛出FileNotFoundException和IOException异常 对于这写可能抛出的异常需要使用相对应的try/catch语句进行捕获 Employee类 123456789101112public class Employee implements java.io.Serializable&#123; public String name; public String address; public transient int SSN; public int number; public void mailCheck() &#123; System.out.println("Mailing a check to " + name + " " + address); &#125;&#125; 序列化代码 12345678910111213141516171819202122232425import java.io.*;public class SerializeDemo&#123; public static void main(String [] args) &#123; Employee e = new Employee(); e.name = "Reyan Ali"; e.address = "Phokka Kuan, Ambehta Peer"; e.SSN = 11122333; e.number = 101; try &#123; FileOutputStream fileOut = new FileOutputStream("./employee.ser"); ObjectOutputStream out = new ObjectOutputStream(fileOut); out.writeObject(e); out.close(); fileOut.close(); System.out.printf("Serialized data is saved in ./employee.ser"); &#125;catch(IOException i) &#123; i.printStackTrace(); &#125; &#125;&#125; 这会把对象e序列化到当前Java工程的根目录下的employee.ser文件中，使用sublime或者notepad++十六进制打开文件 序列化后文件解读（待续……）TODO 反序列化代码 1234567891011121314151617181920212223242526272829303132import java.io.*;public class DeserializeDemo&#123; public static void main(String [] args) &#123; Employee e = null; try &#123; FileInputStream fileIn = new FileInputStream("./employee.ser"); ObjectInputStream in = new ObjectInputStream(fileIn); e = (Employee) in.readObject(); in.close(); fileIn.close(); &#125;catch(IOException i) &#123; i.printStackTrace(); return; &#125;catch(ClassNotFoundException c) &#123; System.out.println("Employee class not found"); c.printStackTrace(); return; &#125; System.out.println("Deserialized Employee..."); System.out.println("Name: " + e.name); System.out.println("Address: " + e.address); System.out.println("SSN: " + e.SSN); System.out.println("Number: " + e.number); System.out.println(ee instanceof Employee); &#125;&#125; 以上程序编译运行结果如下所示： 123456Deserialized Employee...Name: Reyan AliAddress:Phokka Kuan, Ambehta PeerSSN: 0Number:101true Java序列化语法 一个类想要序列化成功必须满足一些条件： 该类必须实现 java.io.Serializable 接口 该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的，有transient关键字修饰 静态static修饰的成员不会被序列化，因为它们是属于类的，而不是某个具体对象的 如果子类实现Serializable接口而父类未实现时，父类不会被序列化！如果父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口。 序列化技术存在的问题整个过程都是Java虚拟机（JVM）独立的，也就是说，在一个平台（Windows，Linux，MacOS）上序列化的对象可以在另一个完全不同的平台上反序列化该对象 序列化技术中有三个过程：序列化，网络传输，反序列化这三个过程都存在严重的安全问题，据不完全统计，至少有3分之1的漏洞是序列化带来的 考虑到这些因素，目前 Oracle 公司计划废除 Java 中的古董—序列化技术，但是序列化技术在Java编程中使用非常的广泛，对此删除序列化技术将是一个长期的计划。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组array]]></title>
    <url>%2F2019%2F03%2F19%2F%E6%95%B0%E7%BB%84array%2F</url>
    <content type="text"><![CDATA[java数组array是固定个数的同种兼容数据类型数据的组织形式 这里首先说下个人自己的观点：array是数据的组织形式，在内存中一段连续的地址空间，但是还没有到达容器的程度，因为数组中元素可以自由访问，没有容器的读写限制 数组的静态和动态创建 静态创建方式： 123int[] arr1=&#123;1,2,3,4&#125;;//或者int[] arr2=new int[]&#123;1,2,3,4&#125;; 创建的时候，确定了数组中的元素值和长度 动态创建方式： 1int[] arr=new int[4]; 创建的时候，不确定数组中的元素值，但是可以确定数组长度 注意： 静态创建方式和动态创建方式不能一起混用，例如下面就会保存 1int[] arr=new int[4]&#123;1,2,3,4&#125;; //报错 数组静态创建和动态创建的区别？ 数组Array的静态创建和动态创建在于创建的时候，是否给数组中元素赋值 数组元素的默认初始化initialization数组静态创建还是动态创建的过程如下： 堆heap分配固定长度内存空间 数组内元素默认初始化default initialization 静态创建与动态创建，此阶段不同： 静态创建，此时给数组中元素用声明的值重新赋值 动态创建，只有默认初始化，是否赋值交给后面的代码 数组的形式是type[]，针对不同的type存在不同的默认初始化值 byte short int long float double默认值0和其变体形式0L 0.0F 0.0D char 默认值 \u0000 引用数据类型默认值 null 数组常见异常 java.lang.ArrayIndexOutOfBoundsException 访问数组索引越界异常 数组是程序运行时兼容数据类型 | 固定长度 | 内存地址连续的引用数据类型 可访问索引范围 index \in [0,n-1] 因此索引越界异常只有：1）上限越界，例如-1 2）下限越界，例如n java.lang.NullPointerException 数组空指针异常 数组在Java中属于引用数据类型，null是任何引用数据类型的默认空值 当int[] arr = null时候，变量arr指向null表示空，因此不存在arr[0]，也不存在任何数组元素 java.lang.NegativeArraySizeException数组初始化长度异常 java.lang.ArrayStoreException数组元素存储异常 数组与对象的关系12int[] arr=new int[4]; System.out.println(arr instanceof int[]); //true 这里使用了new关键字，表示数组也是一种对象类型 而且instanceof运算符的断言结果true也佐证了这一点 ✳数组是特殊的对象，父类是Object类 数组的length属性public， final，int的，因此数组的长度一旦确定，在程序运行阶段是无法改变的 数组的维度Dimension和内存图一维数组：int arr[] = new int[3] 二维数组： 1234int[ ][ ] arr = new int[3][ ]; arr[0] = new int[3]; arr[1] = new int[5]; arr[2] = new int[4]; 扩展：存在3，4，……N维度数组 但是实际上，内存地址是一维线性的，所以内存中除了第一维数组的元素是连续存储的，其他的都是零散无规律分布的 数组不支持泛型比如： 1List&lt;String&gt;[] arr = new ArrayList&lt;String&gt;[10]; 会报错，无法编译通过 根本的原因是：数组在创建的时候必须知道内部元素的类型，而且一直都会记得这个类型信息，每次往数组里添加元素，都会做类型检查。 但因为Java泛型是用擦除（Erasure）实现的，运行时类型参数会被擦掉。所以对于泛型数组，编译器看不到泛型的String类型参数。数组由于无法确定所持有元素的类型，所以不允许初始化 数组协变等待后续…… 数组相关类]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy 12345public class Demo &#123; public static void main(String[] args)&#123; System.out.println("something like go better"); &#125;&#125; e = mc ^ 2More info: Deployment]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
